const fs = require('fs');
const path = require('path');

class horus {
  constructor(name) {
    this.serviceName = name; // represents the name of the microservices
    this.startTime = null;
    this.endTime = null;
    this.request = {};
    this.targetService = null; // represents the location to which the request was made
    this.allRequests = []; // array which stores all requests
  }

  // start should be invoked before the request is made
      // start begins the timer and initializes the request as pending
  start(targetService) {
    this.startTime = Number(process.hrtime.bigint());
    this.request[targetService] = 'pending';
    this.request.responseTime = 'pending';
    this.targetService = targetService;
  }
  // end should be invoked when the request has returned
  end() {
    this.endTime = Number(process.hrtime.bigint());
    this.request.responseTime = this.endTime - this.startTime;
  }
  // grabTrace accepts inserts trace into request
      // trace represents the "journey" of the request
      // trace expects metaData to be 'none when the server made no additional requests
      // trace expects metaData to be the request object generated by the server otherwise
      // in gRPC, the trace must be sent back as meta data. objects should be converted with JSON.parse
  grabTrace (metaData) {
    if (metaData === 'none') this.request[this.targetService] = 'none';
    else {
      metaData = JSON.parse(metaData);
      this.request[this.targetService] = metaData;
    }
    this.allRequests.push(this.request);
  }
  // displayRequests logs to the console all stored requests 
    // setTimeout builds in deliberate latency since metadata may be sent before or after a request is done processing
  displayRequests () {
    console.log('\n\n');
    console.log('Logging all requests from : ', this.serviceName)
    this.allRequests.forEach((request) => {
      console.log('\n'); 
      console.log(request);
    });
    console.log('\n\n')
  }
  writeToFile() {
    let strRequests = '';
    //[ {books: {orders: {}, responseTime: 3}, responseTime: 5}]
    //[ {books: {orders: { Inventory: {}, responseTime: 1}, responseTime: 3}, responseTime: 5}]
    //while object.keys is not an empty array
    //Object.keys = [books]
    //Object.values = [{orders: { Inventory: {}, responseTime: 2}, responseTime: 3}, 5];
          

    for (let req of this.allRequests) {
      //Object.keys = [books]
      //Object.values = [{orders: {}, responseTime: 3}, 5];
      // First write to file - contains Total
      // subsequent - chained requests
      strRequests += `${Object.keys(req)[0]} (service) response received at: ${Object.values(req)[1]} ms (Total)`;
      strRequests += '/n';
      // while we dont hit an empty object on the 1st key, go inside
      let innerObj = Object.values(req)[0];
      while (innerObj) {
        strRequests += `${Object.keys(innerObj)[0]} (service) response received at: ${Object.values(innerObj)[1]} ms`;
        strRequests += '/n';
        innerObj = Object.values(innerObj)[0];
      }
      // go inside 1st value of object recursively?
    }
    // fs.writeFileSync( file, data, options )
    fs.writeFile('requestsFile.txt', strRequests, (err) => {
      if (err) console.error(err);
      console.log('The requests have been logged.');
    });
  }
}

module.exports = horus;